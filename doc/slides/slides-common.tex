%; whizzy-master slides.tex
%; whizzy frame -pdf ./skimopen 
\mode<all>
{\usetheme{Orsay}}

\usepackage{xspace} % To get the right spacings in front of : and so on
\usepackage[english]{babel}
\usepackage{subfigure}
\usepackage{bussproofs}
\usepackage{ottlayout}
\usepackage{pgf}
\usepackage{colortbl}

%\usepackage{xcolor}
\usepackage{abbrevs}
\usepackage[color]{coqdoc}
\def\coqlibrary#1#2{}

\usepackage{hyperref}
\usepackage{coq}
\usepackage{code}
\usepackage{codecolor}
\usepackage{cond}
\usepackage{me}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{pifont}
\usepackage{proof}
\usepackage{utf}
\usepackage{utfmacros}
\usepackage{natbib}

\def\thetitle{\Equations: a dependent pattern-matching compiler}
\def\thetextitleabbr{\thetitle}
\def\thetextitle{\thetextitleabbr}
\def\thesubject{Theoretical Computer Science}
\def\thekeywords{pattern-matching, Dependent Types, recursion}
\def\theevent{
GT Types \& Réalisabilité\\
January 13th 2010\\
Paris, France}
\def\theeventabbr{}

\input{../figures}
\usepackage{prelude-beamer}

\author[\myabbrname{}]{\sc \myname{}}

\pgfdeclareimage[height=1cm]{harvard-logo}{harvard-logo}
\pgfdeclareimage[height=1cm]{coq-logo}{barron-logo}
\pgfdeclareimage[height=4cm]{coq-biglogo}{barron-logo}
\pgfdeclareimage[height=0.4cm]{coq-smalllogo}{barron-logo}

\def\coqdocid#1{\coqdocvar{#1}}

\newqsymbol{"="}{\mathrel{\eqdef}}
\newqsymbol{":="}{\coloneq}

\renewcommand{\bar}[1]{{\overline{#1}}}

\setlength{\coqdocbaseindent}{0em}

\begin{document}

\begin{frame}[plain]
  \titlepage
  \vfill
  \hfill
  \pgfputat{\pgfxy(0,0)}{\pgfbox[right,center]{
      \pgfuseimage{harvard-logo}}}
\end{frame}

\begin{frame}
  \frametitle{Overview}
  
  \begin{itemize}
  \item \Epigram-style pattern-matching definitions with \kw{with} and
    \kw{rec} nodes
  \item Propositional equations for definitional equalities
  \item Elimination principle and support for applying it
  \end{itemize}

  \begin{center}
    \alert{\Huge{DEMO}}
  \end{center}
\end{frame}

\frame<beamer>{\tableofcontents}

\section{Dependent pattern-matching compilation}
\def\hl#1{\textbf{#1}}

\begin{frame}
  \frametitle{Compilation setup}
  
  \begin{center}\hl{Elaboration} into \CIC + K
  \end{center}
  
  Three phases:
  \begin{enumerate}
  \item Generation of a splitting tree from the clauses
  \item Translation from the splitting tree to \Coq terms with holes
  \item Proofs of the obligations using a mix of \ML and \Ltac code
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Input language}

  \begin{figure}
    \[\figdefs\]
  \end{figure}
  
  For $\cst{f}~Δ : τ$ we define $\fcomp{f}~Δ := τ$, so $\cst{f} : Π~Δ, \fcomp{f}~\bar{Δ}$.
\end{frame}

\subsection{Case analysis}

\begin{frame}
  \frametitle{Searching for a splitting tree}

  \begin{figure}
    \[\figsplit\]
  \end{figure}

  Useful invariant: in $\prob{Δ}{\vec{p}}{Γ}$, all variables in Δ appear in \vec{p}.
%  $\prob{Δ}{\vec{p}}{Γ}$: \vec{p} is a substitution from $Δ$ to Γ.

  \vspace{1em}
  \begin{center}
    \alert{Goal} Find a covering of the context map
    \prob{Δ}{\bar{Δ}}{Δ}. This will compile to a term of type $Π
    Δ, \fcomp{f}~\bar{Δ}$

  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Proof search example}

  Overlapping clauses with first-match semantics.

\begin{center}
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Equations} \coqdef{intro.equal}{equal}{\coqdocdefinition{equal}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}) : \{ \coqdocvariable{n} = \coqdocvariable{m} \} + \{ \coqdocvariable{n} \ensuremath{\not=} \coqdocvariable{m} \} :=\coqdoceol
\coqdocnoindent
\coqref{intro.equal}{\coqdocdefinition{equal}} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{O}{\coqdocconstructor{O}} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{O}{\coqdocconstructor{O}} := \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{left}{\coqdocconstructor{left}} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{eqrefl}{\coqdocconstructor{eq\_refl}} ;\coqdoceol
\coqdocnoindent
\coqref{intro.equal}{\coqdocdefinition{equal}} (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}} \coqdocvar{n}) (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}} \coqdocvar{m}) \coqdockw{with} \coqref{intro.equal}{\coqdocdefinition{equal}} \coqdocvariable{n} \coqdocvariable{m} := \{\coqdoceol
\coqdocindent{1.00em}
\coqref{intro.equal}{\coqdocdefinition{equal}} (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}} \coqdocvar{n}) (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}} ?(n)) (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{left}{\coqdocconstructor{left}} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{eqrefl}{\coqdocconstructor{eq\_refl}}) := \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{left}{\coqdocconstructor{left}} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{eqrefl}{\coqdocconstructor{eq\_refl}} ;\coqdoceol
\coqdocindent{1.00em}
\coqref{intro.equal}{\coqdocdefinition{equal}} (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}} \coqdocvar{n}) (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}} \coqdocvar{m}) (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{right}{\coqdocconstructor{right}} \coqdocvar{p}) := \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{right}{\coqdocconstructor{right}} \coqdocvar{\_} \} ;\coqdoceol
\coqdocnoindent
\coqref{intro.equal}{\coqdocdefinition{equal}} \coqdocvar{x} \coqdocvar{y} := \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{right}{\coqdocconstructor{right}} \coqdocvar{\_}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\end{center}  
\end{frame}
  
%\begin{frame}
%   \frametitle{Dependent Pattern-Matching}
  
%   \begin{itemize}
%   \item Patterns = \hl{well-typed} refinements of the signature
%   \item We refine the \hl{entire} context at each node (correct dependency tracking)
%   \item Internalizes ``Uniqueness of Identity Proofs'' (axiom K)
%   \item \hl{Inaccessible} patterns ensure operationality
%   \end{itemize}
% \end{frame}

\begin{frame}
  \frametitle{Translation from the splitting to \Coq}

  For each node with context map $\prob{Δ}{ps}{Γ}$ we generate an
  obligation of type $Π~Δ, \fcomp{f}~ps$.
  
  \begin{enumerate}
  \item $\Split{c}{x}{s}$: witnessed by applying a dependent elimination 
    (\tactic{dependent~destruction}) and using the compiled terms for
    $s$. Empty nodes are translated to empty splittings.
  \item $\Prog{t}$: witnessed by the term.
  \item $\Refine{t}{c}{\ell}{s}$: witnessed by inserting a let-definition in
    the context, strengthening, abstracting and clearing its body, then
    applying the compiled term for label $\ell$.
  \end{enumerate}
\end{frame}

\subsection{\texttt{with} in detail}
\begin{frame}
  \frametitle{With nodes in detail}
  
  Consider a current problem $\prob{Δ}{\vec{p}}{Γ}$ and a user clause 
  $\cst{f}~\vec{up}~\userref{t_{pre}}{e}$ matching it. 
  We typecheck $t_{pre}$ into $t : τ$ and use strenghtening and
  abstraction to find a new context
  \[Δ^t, \var{x_t} : τ, Δ_t[t/\var{x_t}] \text{ such that }
  Δ^t, Δ_t \sim Δ\]

%{\bar{Δ^t}, \bar{Δ_t}}{Δ}\]
  
  % such that there exists maps:
  % \[\prob{Δ}{r}{Δ^t, Δ_t},
  % \prob{Δ^t, Δ_t}{\bar{Δ^t}~t~\bar{Δ_t}}{Δ^t, \var{x_t} : τ, Δ_t[t/\var{x_t}]}\]

  % By composition we have a map
  % \[\prob{Δ}{m}{Δ^t, \var{x_t} : τ, Δ_t[t/\var{x_t}]}\]
  Using the clauses $e$ we then build a subcovering $s$ of the identity context map
  \[c = \texttt{idsubst}({Δ^t, \var{x_t} : τ_Δ, Δ_t[t/\var{x_t}]})\]

  and return $\Refine{t}{c}{\ell.n}{s}$.

  Compilation of the covering we will hence give a term of type 
  $Π~Δ^t~(\var{x_t} : τ_Δ)~Δ_t[t/\var{x_t}],
  (\fcomp{f}~\vec{p})[t/\var{x_t}]$, 
  we can apply it to $\bar{Δ^t}~t~\bar{Δ_t}$ in context $Δ$ to get a
  term of type $Π~Δ, \fcomp{f}~\vec{p}$, giving a witness to the initial problem.

%    {\bar{Δ^t}, \var{x_t}, \bar{Δ_t}}{Δ^t, \var{x_t} : τ_Δ,
%      Δ_t[t/\var{x_t}]}\]

  % As context maps compose this gives us a covering of the original
  % problem. However the clauses $e$ have patterns which are instances of
  % $p$, we can rewrite them to match the variables 
  % $\bar{Δ^t}, \var{x_t}, \bar{Δ_t}$ instead.

\end{frame}

% \begin{frame}
%   \frametitle{Summary}
  
%   \begin{itemize}
%   \item Build a splitting tree using backtracking due to overlapping
%     patterns
%   \item Translation to a \Coq term with holes for the internal nodes
%   \end{itemize}
% \end{frame}

\section{Recursion}
\frame<beamer>{\tableofcontents[currentsection]}

\begin{frame}
  \frametitle{Recursion}
  
  \begin{itemize}
  \item Syntactic recursion is too fragile
  \item Does not work well with abstraction/modularity
  \item Restricted to subterm on one argument
  \end{itemize}

\end{frame}

\subsection{The Below way}

\begin{frame}
  \frametitle{The Below way}
  
  Introduced by McBride and McKinna.

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{Below.Belownat}{Below\_nat}{\coqdocdefinition{Below\_nat}} (\coqdocvar{P} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{n} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} ()\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} (\coqdocvariable{P} \coqdocvariable{n'} \ensuremath{\times} \coqref{Below.Belownat}{\coqdocdefinition{Below\_nat}} \coqdocvariable{P} \coqdocvariable{n'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}\%type.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdef{Below.belownat}{below\_nat}{\coqdocdefinition{below\_nat}} : Π
(\coqdocvar{P} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqdockw{Type}) 
\coqdoceol \coqdocindent{1.00em}
(\coqdocvar{step} : \ensuremath{\Pi} \coqdocvar{n} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}, \coqref{Below.Belownat}{\coqdocdefinition{Below\_nat}} \coqdocvariable{P} \coqdocvariable{n} \ensuremath{\rightarrow} \coqdocvariable{P} \coqdocvariable{n})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}})
: \coqref{Below.Belownat}{\coqdocdefinition{Below\_nat}}
\coqdocvariable{P} \coqdocvariable{n}
\end{coqdoccode}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Below.recnat}{rec\_nat}{\coqdocdefinition{rec\_nat}} (\coqdocvar{P} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqdockw{Type}) \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{step} : \ensuremath{\Pi} \coqdocvar{n} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}, \coqref{Below.Belownat}{\coqdocdefinition{Below\_nat}} \coqdocvariable{P} \coqdocvariable{n} \ensuremath{\rightarrow} \coqdocvariable{P} \coqdocvariable{n}) \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{n} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}) : \coqdocvariable{P} \coqdocvariable{n} :=
\coqdocvariable{step} \coqdocvariable{n} (\coqref{Below.belownat}{\coqdocdefinition{below\_nat}} \coqdocvariable{P} \coqdocvariable{step} \coqdocvariable{n}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\end{frame}

\begin{frame}
  \frametitle{Integration into \Equations}

$\begin{array}{llcl}
  \texttt{user node} & n & \Coloneqq & \ldots `|
  \kw{by}~\kw{rec}~\var{x} \coloneqq \{ \vec{c} \} \\
  \texttt{pattern} & p & \Coloneqq & \ldots `| \hidden{\var{x}} \\
  \texttt{node} & rhs & \Coloneqq & \ldots `| \Rec{\var{x}}{spl}
\end{array}$

\begin{itemize}
\item $\kw{by}~\kw{rec}~\var{x}$ applies the elimination principle
  associated to the type of \var{x} (found using typeclass resolution).
\item Introduce \textbf{hidden} patterns in the problem to carry recursion
  hypotheses of the form $\cst{Below}~(Π~Δ,\fcomp{f}~\vec{t})~x$.
\item Each recursive call is transformed to a trivial projection
  $\fcompproj{f} : Π~Δ~\{p : \fcomp{f}~\bar{Δ}\}, \fcomp{f}~\bar{Δ}$.
\item Proof search for $\fcomp{f}$ goals appearing as obligations,
  unfolding $\cst{Below}$ hypotheses.
\end{itemize}

Automatic proof of the fixpoint equation after defining the unfolded
version where \kw{rec} nodes are ignored (uses proof irrelevance).

\end{frame}

\subsection{Subterm relations}

\begin{frame}
  \frametitle{Subterm relations and well-founded recursion}

  \Below can be very inefficient! Support structural recursion by 
  well-founded recursion on the subterm relation for inductive families.
  
  \begin{itemize}
  \item Same setup, keep the recursor as a hidden
    variable (now of type $Π y : \ind{I}, R~y~x "->"
    \fcomp{f}~\vec{t}$),
    generate obligations for recursive calls.
  \item General definition of subterm (restricted to one inductive type
    currently).
  \item Wrap the inductive type in a sigma and define heterogeneous
    relations as homogeneous relations on the sigma. 
  \item Extract efficiently, but proof search a bit more complicated
    than \Below.
  \end{itemize}
\end{frame}  
\begin{frame}
  \frametitle{Subterm relation example: vectors}
  
  \footnotesize{\input{exsubterm.coq}}
\end{frame}

\section{Reasoning support}
\frame<beamer>{\tableofcontents[currentsection]}

\subsection{Equations}
\begin{frame}
  \frametitle{Equations}
  
  \begin{itemize}
  \item Equations hold definitionally in \CCI + K
  \item Equations for \kw{with} nodes are just proxies to the helper
    function $\cst{f}.\ell$.
  \item All put together in a rewrite database, \cst{f} can now
    be opacified.
  \item For well-founded definitions, we use the unfolding lemma 
    to prove the equations. 
  \end{itemize}
\end{frame}

\subsection{Elimination principle}

\begin{frame}
  \frametitle{Elimination principle: inductive graph}

  For $\cst{f.\ell} : Π~Δ, \fcomp{f}~\vec{t}$ we generate
  $\find{f.\ell} : Π~Δ, \fcomp{f}~\vec{t} "->" \Prop$ and prove 
  $Π~Δ, \find{f.\ell}~\bar{Δ}~(\cst{f.\ell}~\bar{Δ})$.
  \vspace{1em}

  \vspace{1em}

  $\absrec{\cst{f}}{t}$ abstracts all the recursive calls of $\cst{f}$ from the
  term $t$, returning a new derivation $Γ' \vdash t'$ where $Γ'$
  contains all recursive calls of the form $x : Π Δ, \fcomp{f}~\vec{t}$.

  \vspace{1em}

  Define $\IndHyps{Γ}$ by a map to produce the corresponding 
  inductive hyps of the form $H_x : Π Δ, \find{f}~\vec{t}~(x~\bar{Δ})$.
\end{frame}  

\begin{frame}
  \frametitle{Inductive graph constructors}

  Direct translation from the splitting tree:

  \begin{itemize}
  \item $\Split{c}{x}{s}$, $\Rec{v}{s}$ : collect the constructors for
    the subsplitting(s) $s$, if any.

  \item $\Compute{\prob{Δ}{\vec{p}}{Γ}}{rhs}$ :
    By case on $rhs$:
    \begin{itemize}
    \item $\Prog{t}$ : Compute $Ψ \vdash t' = \absrec{f}{t}$ and return 
      the statement \[Π~Δ~Ψ~\IndHyps{Ψ},~\find{f.\ell}~\vec{p}~t'\]

    \item $\Refine{t}{Δ' \vdash \vec{\var{v}}^x, \var{x}, \vec{\var{v}}_x :
        Δ^x, \var{x} : τ, Δ_x}{\ell.n}{s}$ :

      Compute $Ψ \vdash t' = \absrec{f}{t}$ and return:

      \begin{center}
        $Π~Δ~Ψ~\IndHyps{Ψ}~(\var{res} :
        {\fcomp{f}~\vec{p}}) \newline
        \quad~\quad\find{\helper{f}{\ell.n}}~\bar{Δ^x}~t'~\bar{Δ_x}~\var{res} "->"
        \find{f.\ell}~\vec{p}~\var{res}$
      \end{center}
      
      We continue with the generation of the \find{\helper{f}{\ell.n}} graph.
    \end{itemize}  
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Elimination principle}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Equations} \coqdef{filterind.filter}{filter}{\coqdocdefinition{filter}} \{\coqdocvar{A}\} (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}) : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A} :=\coqdoceol
\coqdocnoindent
\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvar{A} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nil}{\coqdocconstructor{nil}} \coqdocvar{p} := \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nil}{\coqdocconstructor{nil}} ;\coqdoceol
\coqdocnoindent
\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvar{A} (\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{cons}{\coqdocconstructor{cons}} \coqdocvar{a} \coqdocvar{l}) \coqdocvar{p} \coqdockw{with} \coqdocvariable{p} \coqdocvariable{a} := \{\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{true}{\coqdocconstructor{true}} := \coqdocvariable{a} :: \coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p} ;\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{false}{\coqdocconstructor{false}} := \coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p} \}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\footnotesize{
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Check} (\coqref{filterind.filterelim}{\coqdocdefinition{filter\_elim}} :\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\forall} \coqdocvar{P} : \ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}), \coqref{filterind.filtercomp}{\coqdocdefinition{filter\_comp}} \coqdocvariable{l} \coqdocvariable{p} \ensuremath{\rightarrow} \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{P0} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{fun} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{a} : \coqdocvariable{A}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}) \coqdoceol
\coqdocindent{3.00em}
(\coqdoctac{refine} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}) (\coqdocvar{H} : \coqref{filterind.filtercomp}{\coqdocdefinition{filter\_comp}} (\coqdocvariable{a} :: \coqdocvariable{l}) \coqdocvariable{p}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{p} \coqdocvariable{a} = \coqdocvariable{refine} \ensuremath{\rightarrow} \coqdocvariable{P} \coqdocvariable{A} (\coqdocvariable{a} :: \coqdocvariable{l}) \coqdocvariable{p} \coqdocvariable{H} \coqdoceol
\coqdocindent{1.00em}
\coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
(\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}), \coqdocvariable{P} \coqdocvariable{A} [] \coqdocvariable{p} []) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{a} : \coqdocvariable{A}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{P} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p}) \ensuremath{\rightarrow} \coqdocvariable{P0} \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{true}{\coqdocconstructor{true}} (\coqdocvariable{a} :: \coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{a} : \coqdocvariable{A}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{P} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p}) \ensuremath{\rightarrow} \coqdocvariable{P0} \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{false}{\coqdocconstructor{false}} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}), \coqdocvariable{P} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p})).\coqdoceol
\end{coqdoccode}}

\end{frame}

\begin{frame}
  \frametitle{Generated mutual induction principle}

\footnotesize{
\begin{coqdoccode}
\coqdockw{Check}(\coqref{filterind.filterindmut}{\coqdocdefinition{filter\_ind\_mut}} :\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\forall} (\coqdocvar{P} : \ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{filterind.filtercomp}{\coqdocdefinition{filter\_comp}} \coqdocvariable{l} \coqdocvariable{p} \ensuremath{\rightarrow} \coqdockw{Prop})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{P0} : \ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{a} : \coqdocvariable{A}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}} \ensuremath{\rightarrow} \coqref{filterind.filtercomp}{\coqdocdefinition{filter\_comp}} (\coqdocvariable{a} :: \coqdocvariable{l}) \coqdocvariable{p} \ensuremath{\rightarrow} \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
(\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}), \coqdocvariable{P} \coqdocvariable{A} [] \coqdocvariable{p} []) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{a} : \coqdocvariable{A}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{filterind.filterind1}{\coqdocinductive{filter\_ind\_1}} \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} (\coqdocvariable{p} \coqdocvariable{a}) (\coqref{filterind.filterobligation2}{\coqdoclemma{filter\_obligation\_2}} (@\coqref{filterind.filter}{\coqdocdefinition{filter}}) \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} (\coqdocvariable{p} \coqdocvariable{a})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{P0} \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} (\coqdocvariable{p} \coqdocvariable{a}) (\coqref{filterind.filterobligation2}{\coqdoclemma{filter\_obligation\_2}} (@\coqref{filterind.filter}{\coqdocdefinition{filter}}) \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} (\coqdocvariable{p} \coqdocvariable{a})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{P} \coqdocvariable{A} (\coqdocvariable{a} :: \coqdocvariable{l}) \coqdocvariable{p} (\coqref{filterind.filterobligation2}{\coqdoclemma{filter\_obligation\_2}} (@\coqref{filterind.filter}{\coqdocdefinition{filter}}) \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} (\coqdocvariable{p} \coqdocvariable{a}))) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{a} : \coqdocvariable{A}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{filterind.filterind}{\coqdocinductive{filter\_ind}} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{P} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p}) \ensuremath{\rightarrow} \coqdocvariable{P0} \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{true}{\coqdocconstructor{true}} (\coqdocvariable{a} :: \coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{a} : \coqdocvariable{A}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{filterind.filterind}{\coqdocinductive{filter\_ind}} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{P} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p}) \ensuremath{\rightarrow} \coqdocvariable{P0} \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqdocvariable{p} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{false}{\coqdocconstructor{false}} (\coqref{filterind.filter}{\coqdocdefinition{filter}} \coqdocvariable{l} \coqdocvariable{p})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\forall} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{l} : \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{p} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{bool}{\coqdocinductive{bool}}) (\coqdocvar{f3} : \coqref{filterind.filtercomp}{\coqdocdefinition{filter\_comp}} \coqdocvariable{l} \coqdocvariable{p}),\coqdoceol
\coqdocindent{2.00em}
\coqref{filterind.filterind}{\coqdocinductive{filter\_ind}} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} \coqdocvariable{f3} \ensuremath{\rightarrow} \coqdocvariable{P} \coqdocvariable{A} \coqdocvariable{l} \coqdocvariable{p} \coqdocvariable{f3}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}}

\end{frame}

\subsection{Eliminating calls}

\begin{frame}
  \frametitle{Eliminating calls}

  The elimination principle can only be applied usefully to calls with
  solely variable arguments. Use the same ``abstraction by equalities''
  technique to solve this.

  If $τ = C[\cst{f}~\vec{t}]$ we generate 
  \[(λ~Δ~(r : \fcomp{f}~\bar{Δ}), \vec{Δ_i = t_i} "->" r \simeq \cst{f}~\vec{t}
  "->" τ)~\vec{t}~(\cst{f}~\vec{t})\]
\end{frame}


\begin{frame}
  \frametitle{Conclusion}
  
  A function definition package handling:
  \begin{itemize}
  \item Full, nested dependent pattern-matching
  \item Structural and well-founded recursion on dependent types
  \item Generation of useful support lemmas for reasoning a posteriori
  \end{itemize}
  
  Tested on a bit-fiddling library: less boilerplate, shorter proofs.
\end{frame}

\begin{frame}
  \frametitle{Perspectives}
  
  \begin{itemize}
  \item Treatment of non-constructor indices and constraints
  \item Mutual recursion, support for measures
  \item Efficiency, a primitive handling of dependent elimination
    internalizing K would help (hint !)

  \item Move to \ind{eq\_dep} instead of \ind{JMeq}?
  \end{itemize}
  
\end{frame}

\begin{frame}
  \frametitle{The End}

  \begin{center}
    \pgfuseimage{coq-biglogo}
  \end{center}
\end{frame}
\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-PDF-mode: t
%%% LaTeX-command: "x=pdf; TEXINPUTS=\"~/research/publication/figures:~/research/publication/styles:~/research/coq/Russell/papers:$TEXINPUTS:\" ${pdfx}pdflatex"
%%% TeX-master: "slides"
%%% End: 
