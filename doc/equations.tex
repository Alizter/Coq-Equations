\documentclass[9pt]{sigplanconf}

\usepackage{me}
\def\anon#1{#1}
\def\theauthor{\anon{\myname}}

%% JFP

%% LLNCS
% \author{\theauthor}
% \date{\today}
% \institute{\myaffiliation
%   \\\email{sozeau@lri.fr}}
% \usepackage{natbib}
% \bibpunct();A{},
% \let\cite=\citep
% \def\shortcite#1{\cite{#1}}

%% ACM
\authorinfo{\myname}{\myaffiliation}{\mymail}

%\documentclass{article}

\usepackage{abbrevs}
\usepackage[color]{coqdoc}
\usepackage{coq}
\usepackage{natbib}
\setlength{\coqdocbaseindent}{0.7em}
\usepackage{utf}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{conjecture}{Conjecture}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{corrolary}[theorem]{Corollary}
\newtheorem{notation}[theorem]{Notation}

\def\Equations{\name{Equations}}
\def\coqlibrary#1#2#3{}
\def\Below{\coqdocind{Below}\xspace}

\def\teles#1{\ensuremath{Σ(#1)}}
\def\bars#1#2{\ensuremath{\bar{Σ}(#1, #2)}}
\def\fcompproj#1{\ensuremath{\cst{#1}_{comp\_proj}}} 
\def\find#1{\ensuremath{\cst{#1}_{ind}}}
\def\fcomp#1{\ensuremath{\cst{#1}_{comp}}}
\def\absrec#1#2{\textsc{AbsRec}(#1,#2)}

\def\var{\coqdocvar}
\def\cstr{\coqdocconstr}
\def\cst{\coqdoccst}
\def\ind{\coqdocind}
\def\Split#1#2#3{\texttt{Split}(#1, #2, #3)}
\def\Compute#1#2{\texttt{Compute}(#1, #2)}
\def\Prog#1{\texttt{Program}(#1)}
\def\Empty#1{\texttt{Empty}(#1)}
\def\Refine#1#2#3#4{\texttt{Refine}(#1, #2, #3, #4)}

\def\eqrefl{\coqexternalref{http://coq.inria.fr/distrib/trunk/stdlib/Coq.Init.Logic}{eqrefl}{\coqdocconstructor{eq\_refl}}}

%\author{Matthieu Sozeau}
\title{\Equations\\
  A dependent pattern-matching compiler}

\begin{document}
\maketitle

\begin{abstract}
  We present a compiler for definitions made by pattern matching on
  inductive families in the \Coq system. It allows to write structured,
  recursive dependently-typed functions, automatically find their
  realization in the core type theory and generate proofs to ease
  reasoning on them.
  
  The basic functionality is the ability to define a function by a set
  of \textit{equations} with patterns on the left-hand side and programs
  on the right-hand side, in a similar fashion to \Haskell
  function definitions. The system also supports with-clauses (as in
  \Epigram or \Agda) that can be used to add a pattern on the left-hand
  side for further refinement. Both "syntactic" structural recursion and
  "semantic" well-founded recursion schemes are usable in definitions,
  the later being generalized enough to cope with general inductive
  families efficiently.
  
  The system provides proofs of the equations that can be used as
  rewrite rules to reason on calls to the function. It also
  automatically generates the inductive graph of the function and a
  proof that the function respects it, giving a useful induction
  principle for it.

  It provides a complete package to define 
  and reason on functions in the proof assistant, substantially
  reducing the boilerplate code and proofs one usually has to write, 
  also hiding the intricacies related to the use of dependent types.
  
  The system is implemented as an elaboration into the core \Coq type
  theory, allowing the smallest trusted code base possible and ensuring 
  the correctness of the compilation at each use.
  The whole system makes heavy use of type classes and the high-level
  tactic language of \Coq for greater genericity and extensibility.
\end{abstract}

\input{intro.coq}
\input{implem}
\input{support}
\input{experiments}
\input{conclusion}

  
\bibliographystyle{plainnat}
\bibliography{biblio}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: t
%%% End: 